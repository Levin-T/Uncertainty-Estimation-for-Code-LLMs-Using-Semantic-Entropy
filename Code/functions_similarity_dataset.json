[
  {
    "function1": "def add_numbers(p, q):\n    return p + q",
    "function2": "def sum_values(a, b):\n    result = a + b\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def reverse_string(s):\n    return s[::-1]",
    "function2": "def invert_text(t):\n    result = ''.join(reversed(t))\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def is_even_number(n):\n    return n % 2 == 0",
    "function2": "def check_parity(x):\n    return True if x % 2 == 0 else False",
    "same_behavior": 1
  },
  {
    "function1": "def recursive(n):\n    if n == 0:\n        return 1\n    return n * recursive_factorial(n - 1)",
    "function2": "def iterative_lol(x):\n    result = 1\n    for i in range(1, x + 1):\n        result *= i\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def find_maximum(lst):\n    return max(lst)",
    "function2": "def maximum_value(nums):\n    max_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n    return max_value",
    "same_behavior": 1
  },
  {
    "function1": "def compute_square(x):\n    return x * x",
    "function2": "def duplicate_value(y):\n    return y + y",
    "same_behavior": 0
  },
  {
    "function1": "def sum_two_numbers(a, b):\n    return a + b",
    "function2": "def multiply_two_numbers(p, q):\n    return p * q",
    "same_behavior": 0
  },
  {
    "function1": "def concatenate_strings(s1, s2):\n    return s1 + s2",
    "function2": "def join_strings_with_and(str1, str2):\n    return f\"{str1} and {str2}\"",
    "same_behavior": 0
  },
  {
    "function1": "def is_even(n):\n    return n % 2 == 0",
    "function2": "def is_divisible_by_three(n):\n    return n % 3 == 0",
    "same_behavior": 0
  },
  {
    "function1": "def string_length(s):\n    return len(s)",
    "function2": "def count_characters_doubled(t):\n    return sum(2 for _ in t)",
    "same_behavior": 0
  },
  {
    "function1": "def combine_texts(s1, s2):\n    return s1 + s2",
    "function2": "def merge_words(a, b):\n    return f\"{a}{b}\"",
    "same_behavior": 1
  },
  {
    "function1": "def absolute_value(x):\n    return x if x >= 0 else -x",
    "function2": "def compute_absolute(n):\n    import math\n    return int(math.fabs(n))",
    "same_behavior": 1
  },
  {
    "function1": "def sum_list_elements(numbers):\n    return sum(numbers)",
    "function2": "def total_numbers(nums):\n    total = 0\n    for num in nums:\n        total += num\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def palindrome_checker(s):\n    return s == s[::-1]",
    "function2": "def verify_palindrome(text):\n    reversed_text = ''.join(reversed(text))\n    return text == reversed_text",
    "same_behavior": 1
  },
  {
    "function1": "def multiply_numbers(a, b):\n    return a * b",
    "function2": "def repeated_addition(x, y):\n    result = 0\n    for _ in range(y):\n        result += x\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def invert_string(s):\n    return s[::-1]",
    "function2": "def sort_characters(s):\n    return ''.join(sorted(s))",
    "same_behavior": 0
  },
  {
    "function1": "def factorial_calc(n):\n    if n == 0:\n        return 1\n    return n * factorial_calc(n - 1)",
    "function2": "def double_number(x):\n    return x + x",
    "same_behavior": 0
  },
  {
    "function1": "def is_number_positive(n):\n    return n > 0",
    "function2": "def is_number_even(n):\n    return n % 2 == 0",
    "same_behavior": 0
  },
  {
    "function1": "def get_max_value(lst):\n    return max(lst)",
    "function2": "def get_min_value(lst):\n    return min(lst)",
    "same_behavior": 0
  },
  {
    "function1": "def concatenate_with_space(s1, s2):\n    return s1 + \" \" + s2",
    "function2": "def combine_strings_with_case(a, b):\n    return a.upper() + \" \" + b.lower()",
    "same_behavior": 0
  },
  {
    "function1": "def compute_factorial_recursive(n):\n    if n == 0:\n        return 1\n    return n * compute_factorial_recursive(n - 1)",
    "function2": "def compute_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def compute_gcd_euclid(a, b):\n    while b:\n        a, b = b, a % b\n    return a",
    "function2": "def gcd_via_recursion(a, b):\n    return a if b == 0 else gcd_via_recursion(b, a % b)",
    "same_behavior": 1
  },
  {
    "function1": "def recursive_twitch(lst):\n    if not lst:\n        return []\n    if isinstance(lst[0], list):\n        return recursive_flatten(lst[0]) + recursive_flatten(lst[1:])\n    return [lst[0]] + recursive_flatten(lst[1:])",
    "function2": "def iterative_fska(lst):\n    stack, result = [lst], []\n    while stack:\n        current = stack.pop()\n        if isinstance(current, list):\n            stack.extend(reversed(current))\n        else:\n            result.append(current)\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def wdwefs(base, exp):\n    return 1 if exp == 0 else base * recursive_power(base, exp - 1)",
    "function2": "def iterative_pfesf(base, exp):\n    result = 1\n    for _ in range(exp):\n        result *= base\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def merger(l1, l2):\n    if not l1:\n        return l2\n    if not l2:\n        return l1\n    if l1[0] < l2[0]:\n        return [l1[0]] + merge_lists_recursively(l1[1:], l2)\n    return [l2[0]] + merge_lists_recursively(l1, l2[1:])",
    "function2": "def stuff_list(l1, l2):\n    result, i, j = [], 0, 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] < l2[j]:\n            result.append(l1[i])\n            i += 1\n        else:\n            result.append(l2[j])\n            j += 1\n    result.extend(l1[i:])\n    result.extend(l2[j:])\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def calculate_average(numbers):\n    return sum(numbers) / len(numbers)",
    "function2": "def multiply_sum_and_length(numbers):\n    return sum(numbers) * len(numbers)",
    "same_behavior": 0
  },
  {
    "function1": "def frobnicate_sequence(seq):\n    return [x * 2 for x in seq if x % 2 == 0]",
    "function2": "def double_evens(lst):\n    result = []\n    for num in lst:\n        if num % 2 == 0:\n            result.append(num * 2)\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def quibble_sort(data):\n    return sorted(data, key=lambda x: x[1])",
    "function2": "def sort_by_second_element(arr):\n    arr.sort(key=lambda element: element[1])\n    return arr",
    "same_behavior": 1
  },
  {
    "function1": "def rotate_matrix(mat):\n    return [list(reversed(col)) for col in zip(*mat)]",
    "function2": "def transpose_and_reverse(matrix):\n    transposed = zip(*matrix)\n    return [list(row)[::-1] for row in transposed]",
    "same_behavior": 1
  },
  {
    "function1": "def generate_primes(n):\n    primes = []\n    for num in range(2, n+1):\n        is_prime = all(num % i != 0 for i in range(2, int(num**0.5)+1))\n        if is_prime:\n            primes.append(num)\n    return primes",
    "function2": "def sieve_primes(limit):\n    sieve = [True] * (limit+1)\n    sieve[0:2] = [False, False]\n    for i in range(2, int(limit**0.5)+1):\n        if sieve[i]:\n            sieve[i*i:limit+1:i] = [False]*len(range(i*i, limit+1, i))\n    return [i for i, prime in enumerate(sieve) if prime]",
    "same_behavior": 1
  },
  {
    "function1": "def calculate_median(nums):\n    nums = sorted(nums)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2 -1] + nums[n//2]) / 2\n    else:\n        return nums[n//2]",
    "function2": "def find_median(values):\n    from statistics import median\n    return median(values)",
    "same_behavior": 1
  },
  {
    "function1": "def check_balanced_symbols(expr):\n    stack = []\n    pairs = {'(': ')', '{': '}', '[': ']'}\n    for char in expr:\n        if char in pairs:\n            stack.append(char)\n        elif char in pairs.values():\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    return not stack",
    "function2": "def is_symbols_balanced(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack",
    "same_behavior": 1
  },
  {
    "function1": "def flatten_nested_list(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten_nested_list(item))\n        else:\n            result.append(item)\n    return result",
    "function2": "def deep_flatten(lst):\n    from collections.abc import Iterable\n    for el in lst:\n        if isinstance(el, Iterable) and not isinstance(el, (str, bytes)):\n            yield from deep_flatten(el)\n        else:\n            yield el",
    "same_behavior": 1
  },
  {
    "function1": "def compute_factorial(n):\n    from math import factorial\n    return factorial(n)",
    "function2": "def recursive_factorial(num):\n    return 1 if num == 0 else num * recursive_factorial(num - 1)",
    "same_behavior": 1
  },
  {
    "function1": "def levenshtein_distance(s1, s2):\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    if len(s2) == 0:\n        return len(s1)\n    previous_row = range(len(s2) + 1)\n    for i, c1 in enumerate(s1):\n        current_row = [i + 1]\n        for j, c2 in enumerate(s2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]",
    "function2": "def edit_distance(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]",
    "same_behavior": 1
  },
  {
    "function1": "def serialize_tree(root):\n    values = []\n    def preorder(node):\n        if node:\n            values.append(node.val)\n            preorder(node.left)\n            preorder(node.right)\n        else:\n            values.append(None)\n    preorder(root)\n    return values",
    "function2": "def tree_to_list(node):\n    if not node:\n        return [None]\n    return [node.val] + tree_to_list(node.left) + tree_to_list(node.right)",
    "same_behavior": 1
  },
  {
    "function1": "def invert_binary_tree(root):\n    if root:\n        root.left, root.right = invert_binary_tree(root.right), invert_binary_tree(root.left)\n    return root",
    "function2": "def mirror_tree(node):\n    if node:\n        node.left, node.right = node.right, node.left\n        mirror_tree(node.left)\n        mirror_tree(node.right)\n    return node",
    "same_behavior": 1
  },
  {
    "function1": "def count_inversions(arr):\n    def merge_sort(lst):\n        inv_count = 0\n        if len(lst) > 1:\n            mid = len(lst) // 2\n            left = lst[:mid]\n            right = lst[mid:]\n            inv_count += merge_sort(left)\n            inv_count += merge_sort(right)\n            i = j = k = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    lst[k] = left[i]\n                    i += 1\n                else:\n                    lst[k] = right[j]\n                    inv_count += len(left) - i\n                    j += 1\n                k += 1\n            while i < len(left):\n                lst[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                lst[k] = right[j]\n                j += 1\n                k += 1\n        return inv_count\n    return merge_sort(arr.copy())",
    "function2": "def inversion_count(array):\n    count = 0\n    for i in range(len(array)):\n        for j in range(i+1, len(array)):\n            if array[i] > array[j]:\n                count += 1\n    return count",
    "same_behavior": 1
  },
  {
    "function1": "def longest_common_subsequence(X, Y):\n    m, n = len(X), len(Y)\n    L = [[0]*(n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    return L[m][n]",
    "function2": "def lcs_length(s1, s2):\n    from functools import lru_cache\n    @lru_cache(maxsize=None)\n    def lcs(i, j):\n        if i == len(s1) or j == len(s2):\n            return 0\n        elif s1[i] == s2[j]:\n            return 1 + lcs(i+1, j+1)\n        else:\n            return max(lcs(i+1, j), lcs(i, j+1))\n    return lcs(0, 0)",
    "same_behavior": 1
  },
  {
    "function1": "def is_bst(node, min_val=float('-inf'), max_val=float('inf')):\n    if not node:\n        return True\n    if not (min_val < node.val < max_val):\n        return False\n    return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)",
    "function2": "def validate_bst(root):\n    def inorder_traversal(node):\n        return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else []\n    inorder = inorder_traversal(root)\n    return inorder == sorted(set(inorder))",
    "same_behavior": 1
  },
  {
  "function1": "def zeta_alpha(a, b):\n    return a * b",
  "function2": "def omega_beta(a, b):\n    return 0.5 * a * b",
  "same_behavior": 0
  },
  {
  "function1": "def gamma_delta(x, y):\n    return x / y",
  "function2": "def epsilon_theta(x, y):\n    return y / x",
  "same_behavior": 0
  },
  {
  "function1": "def pi_rho(n):\n    total = 0\n    for i in range(n + 1):\n        total += i\n    return total",
  "function2": "def sigma_tau(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i * i\n    return total",
  "same_behavior": 0
  },
  {
  "function1": "def upsilon_phi(lst):\n    return [x * 2 for x in lst]",
  "function2": "def chi_psi(lst):\n    return [x ** 2 for x in lst]",
  "same_behavior": 0
  },
  {
  "function1": "def omega_zeta(n):\n    return sum([i * i for i in range(1, n + 1)])",
  "function2": "def eta_theta(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 2\n    return total",
  "same_behavior": 1
  },
  {
  "function1": "def iota_kappa(n):\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True",
  "function2": "def lambda_mu(num):\n    import math\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True",
  "same_behavior": 1
  },
  {
  "function1": "def nu_xi(d1, d2):\n    return {**d1, **d2}",
  "function2": "def omicron_pi(dict1, dict2):\n    result = dict1.copy()\n    result.update(dict2)\n    return result",
  "same_behavior": 1
  },
  {
  "function1": "def phi_chi(s):\n    return sum(1 for c in s.lower() if c in 'aeiou')",
  "function2": "def psi_omega(s):\n    vowels = 'aeiou'\n    count = 0\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    return count",
  "same_behavior": 1
  },
  {
    "function1": "def gamma_serialize(root):\\n    from collections import deque\\n    result = []\\n    queue = deque([root])\\n    while queue:\\n        node = queue.popleft()\\n        if node:\\n            result.append(node.val)\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        else:\\n            result.append(None)\\n    return result",
    "function2": "def delta_serialize(root):\\n    result = []\\n    def preorder(node):\\n        if node:\\n            result.append(node.val)\\n            preorder(node.left)\\n            preorder(node.right)\\n        else:\\n            result.append(None)\\n    preorder(root)\\n    return result",
    "same_behavior": 0
  },
  {
    "function1": "def epsilon_lca(root, p, q):\\n    if not root or root == p or root == q:\\n        return root\\n    left = epsilon_lca(root.left, p, q)\\n    right = epsilon_lca(root.right, p, q)\\n    if left and right:\\n        return root\\n    return left if left else right",
    "function2": "def zeta_lca(root, p, q):\\n    parent = {root: None}\\n    stack = [root]\\n    while p not in parent or q not in parent:\\n        node = stack.pop()\\n        if node.left:\\n            parent[node.left] = node\\n            stack.append(node.left)\\n        if node.right:\\n            parent[node.right] = node\\n            stack.append(node.right)\\n    ancestors = set()\\n    while p:\\n        ancestors.add(p)\\n        p = parent[p]\\n    while q not in ancestors:\\n        q = parent[q]\\n    return q",
    "same_behavior": 1
  },
  {
    "function1": "def eta_unique_paths(m, n):\\n    dp = [[1]*n for _ in range(m)]\\n    for i in range(1, m):\\n        for j in range(1, n):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n    return dp[m-1][n-1]",
    "function2": "def theta_unique_paths_with_diagonal(m, n):\\n    dp = [[1]*n for _ in range(m)]\\n    for i in range(1, m):\\n        for j in range(1, n):\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\\n    return dp[m-1][n-1]",
    "same_behavior": 0
  },
  {
    "function1": "def lambda_tower_of_hanoi(n, source, auxiliary, target):\\n    if n > 0:\\n        lambda_tower_of_hanoi(n-1, source, target, auxiliary)\\n        print(f\"Move disk {n} from {source} to {target}\")\\n        lambda_tower_of_hanoi(n-1, auxiliary, source, target)",
    "function2": "def mu_tower_of_hanoi_iterative(n, source, auxiliary, target):\\n    total_moves = 2**n - 1\\n    poles = {source: list(range(n, 0, -1)), auxiliary: [], target: []}\\n    if n % 2 == 0:\\n        auxiliary, target = target, auxiliary\\n    for i in range(1, total_moves + 1):\\n        if i % 3 == 1:\\n            move_disk(poles, source, target)\\n        elif i % 3 == 2:\\n            move_disk(poles, source, auxiliary)\\n        elif i % 3 == 0:\\n            move_disk(poles, auxiliary, target)\\n\\ndef move_disk(poles, from_pole, to_pole):\\n    from_stack = poles[from_pole]\\n    to_stack = poles[to_pole]\\n    if not from_stack:\\n        disk = to_stack.pop()\\n        from_stack.append(disk)\\n        print(f\"Move disk {disk} from {to_pole} to {from_pole}\")\\n    elif not to_stack:\\n        disk = from_stack.pop()\\n        to_stack.append(disk)\\n        print(f\"Move disk {disk} from {from_pole} to {to_pole}\")\\n    elif from_stack[-1] > to_stack[-1]:\\n        disk = to_stack.pop()\\n        from_stack.append(disk)\\n        print(f\"Move disk {disk} from {to_pole} to {from_pole}\")\\n    else:\\n        disk = from_stack.pop()\\n        to_stack.append(disk)\\n        print(f\"Move disk {disk} from {from_pole} to {to_pole}\")",
    "same_behavior": 1
  },
  {
    "function1": "def rho_dfs(graph, start, visited=None):\\n    if visited is None:\\n        visited = set()\\n    visited.add(start)\\n    print(start, end=' ')\\n    for neighbor in graph[start]:\\n        if neighbor not in visited:\\n            rho_dfs(graph, neighbor, visited)",
    "function2": "def sigma_bfs(graph, start):\\n    visited = set()\\n    queue = [start]\\n    while queue:\\n        vertex = queue.pop(0)\\n        if vertex not in visited:\\n            visited.add(vertex)\\n            print(vertex, end=' ')\\n            queue.extend(set(graph[vertex]) - visited)",
    "same_behavior": 0
  },
  {
    "function1": "def tau_quicksort(arr):\\n    if len(arr) <= 1:\\n        return arr\\n    else:\\n        pivot = arr[0]\\n        less = [x for x in arr[1:] if x <= pivot]\\n        greater = [x for x in arr[1:] if x > pivot]\\n        return tau_quicksort(less) + [pivot] + tau_quicksort(greater)",
    "function2": "def upsilon_heapsort(arr):\\n    import heapq\\n    heapq.heapify(arr)\\n    sorted_arr = [heapq.heappop(arr) for _ in range(len(arr))]\\n    return sorted_arr",
    "same_behavior": 1
  },
  {
    "function1": "def phi_exponential(x, terms=10):\\n    result = 1\\n    factorial = 1\\n    for n in range(1, terms):\\n        factorial *= n\\n        result += x ** n / factorial\\n    return result",
    "function2": "def chi_natural_log(x, terms=10):\\n    if x <= 0:\\n        return float('nan')\\n    y = (x - 1) / x\\n    result = 0\\n    for n in range(1, terms + 1):\\n        result += y ** n / n\\n    return result",
    "same_behavior": 0
  },
  {
    "function1": "def alpha_fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return alpha_fibonacci(n - 1) + alpha_fibonacci(n - 2)",
    "function2": "def beta_fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
    "same_behavior": 1
  },
  {
    "function1": "def gamma_are_anagrams(s1, s2):\n    return sorted(s1) == sorted(s2)",
    "function2": "def delta_are_anagrams(s1, s2):\n    from collections import Counter\n    return Counter(s1) == Counter(s2)",
    "same_behavior": 1
  },
  {
    "function1": "def eta_sum_of_digits(n):\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total",
    "function2": "def theta_product_of_digits(n):\n    total = 1\n    while n > 0:\n        total *= n % 10\n        n //= 10\n    return total",
    "same_behavior": 0
  },
  {
    "function1": "def lambda_count_uppercase(s):\n    count = 0\n    for c in s:\n        if c.isupper():\n            count += 1\n    return count",
    "function2": "def mu_count_lowercase(s):\n    count = 0\n    for c in s:\n        if c.islower():\n            count += 1\n    return count",
    "same_behavior": 0
  },
  {
    "function1": "def nu_find_mode(lst):\n    from collections import Counter\n    data = Counter(lst)\n    mode = data.most_common(1)[0][0]\n    return mode",
    "function2": "def xi_most_frequent(lst):\n    frequency = {}\n    max_count = 0\n    mode = None\n    for x in lst:\n        frequency[x] = frequency.get(x, 0) + 1\n        if frequency[x] > max_count:\n            max_count = frequency[x]\n            mode = x\n    return mode",
    "same_behavior": 1
  },
  {
    "function1": "def rho_determinant(matrix):\n    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]",
    "function2": "def sigma_determinant(matrix):\n    a, b = matrix[0]\n    c, d = matrix[1]\n    return a * d - b * c",
    "same_behavior": 1
  },
  {
    "function1": "def tau_dot_product(v1, v2):\n    return sum(x * y for x, y in zip(v1, v2))",
    "function2": "def upsilon_cross_product(v1, v2):\n    return [\n        v1[1] * v2[2] - v1[2] * v2[1],\n        v1[2] * v2[0] - v1[0] * v2[2],\n        v1[0] * v2[1] - v1[1] * v2[0]\n    ]",
    "same_behavior": 0
  },

  {
    "function1": "def zlya_sort_by_last(items):\\n    return sorted(items, key=lambda x: x[-1])",
    "function2": "def zlyb_sort_by_last_alt(items):\\n    items_sorted = list(items)\\n    items_sorted.sort(key=lambda x: x[-1])\\n    return items_sorted",
    "same_behavior": 1
  },
  {
    "function1": "def zlyc_is_sorted_loop(arr):\\n    for i in range(len(arr) - 1):\\n        if arr[i] > arr[i+1]:\\n            return False\\n    return True",
    "function2": "def zlyd_is_sorted_builtin(arr):\\n    return arr == sorted(arr)",
    "same_behavior": 1
  },
  {
    "function1": "def zlye_str_upper_loop(s):\\n    result = ''\\n    for ch in s:\\n        if 'a' <= ch <= 'z':\\n            result += chr(ord(ch) - 32)\\n        else:\\n            result += ch\\n    return result",
    "function2": "def zlyf_str_upper_method(s):\\n    return s.upper()",
    "same_behavior": 0
    },
  {
    "function1": "def zlyg_count_vowels_set(text):\\n    vowels = set('aeiouAEIOU')\\n    return sum(1 for ch in text if ch in vowels)",
    "function2": "def zlyh_count_vowels_loop(text):\\n    count = 0\\n    for ch in text:\\n        if ch.lower() in 'aeiou':\\n            count += 1\\n    return count",
    "same_behavior": 1
  },
  {
    "function1": "def zlyi_partial_sum_loop(n):\\n    total = 0\\n    for i in range(1, n+1):\\n        total += i\\n    return total",
    "function2": "def zlyj_partial_sum_math(n):\\n    # sum of first n natural numbers = n*(n+1)//2\\n    return n * (n + 1) // 2",
    "same_behavior": 1
  },
  {
    "function1": "def zlyk_shift_left_slice(lst):\\n    if not lst:\\n        return []\\n    return lst[1:] + lst[:1]",
    "function2": "def zlyl_shift_left_deque(lst):\\n    from collections import deque\\n    dq = deque(lst)\\n    if dq:\\n        dq.append(dq.popleft())\\n    return list(dq)",
    "same_behavior": 1
  },
  {
    "function1": "def zlym_filter_even_comp(nums):\\n    return [x for x in nums if x % 2 == 0]",
    "function2": "def zlyn_filter_even_filter(nums):\\n    return list(filter(lambda x: x % 2 == 0, nums))",
    "same_behavior": 1
  },
  {
    "function1": "def zlyo_bubble_sort(arr):\\n    arr = arr[:]\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n-i-1):\\n            if arr[j] > arr[j+1]:\\n                arr[j], arr[j+1] = arr[j+1], arr[j]\\n    return arr",
    "function2": "def zlyp_insertion_sort(arr):\\n    arr = arr[:]\\n    for i in range(1, len(arr)):\\n        key = arr[i]\\n        j = i-1\\n        while j >= 0 and arr[j] > key:\\n            arr[j+1] = arr[j]\\n            j -= 1\\n        arr[j+1] = key\\n    return arr",
    "same_behavior": 1
  },
  {
    "function1": "def zlyq_balance_paren_stack(expr):\\n    stack = []\\n    for ch in expr:\\n        if ch == '(':\\n            stack.append(ch)\\n        elif ch == ')':\\n            if not stack:\\n                return False\\n            stack.pop()\\n    return len(stack) == 0",
    "function2": "def zlyr_balance_paren_count(expr):\\n    count = 0\\n    for ch in expr:\\n        if ch == '(':\\n            count += 1\\n        elif ch == ')':\\n            count -= 1\\n            if count < 0:\\n                return False\\n    return count == 0",
    "same_behavior": 1
  },
  {
    "function1": "def zlys_count_words_split(text):\\n    return len(text.split())",
    "function2": "def zlyt_count_words_regex(text):\\n    import re\\n    words = re.findall(r'\\\\S+', text)\\n    return len(words)",
    "same_behavior": 1
  },
  {
    "function1": "def zlyu_second_largest_sort(nums):\\n    unique_nums = list(set(nums))\\n    unique_nums.sort()\\n    if len(unique_nums) < 2:\\n        return None\\n    return unique_nums[-2]",
    "function2": "def zlyv_second_largest_loop(nums):\\n    first = second = float('-inf')\\n    for x in nums:\\n        if x > first:\\n            second = first\\n            first = x\\n        elif x > second and x != first:\\n            second = x\\n    return second if second != float('-inf') else None",
    "same_behavior": 1
  },
  {

    "function1": "def zlyy_reverse_list_iter(lst):\\n    rev = []\\n    for item in lst:\\n        rev.insert(0, item)\\n    return rev",
    "function2": "def zlyz_reverse_list_recur(lst):\\n    if len(lst) <= 1:\\n        return lst\\n    return [lst[-1]] + zlyz_reverse_list_recur(lst[:-1])",
    "same_behavior": 1
  },
  {
    "function1": "def zmaa_is_leap_year_cond(year):\\n    if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0):\\n        return True\\n    return False",
    "function2": "def zmab_is_leap_year_logic(y):\\n    return (y % 400 == 0) or (y % 4 == 0 and y % 100 != 0)",
    "same_behavior": 1
  },
  {
    "function1": "def zmac_sum_of_squares_loop(n):\\n    total = 0\\n    for i in range(1, n+1):\\n        total += i*i\\n    return total",
    "function2": "def zmad_sum_of_squares_comp(n):\\n    return sum(i*i for i in range(1, n+1))",
    "same_behavior": 1
  },
  {
    "function1": "def abcd_cube(p):\n    return p * p * p",
    "function2": "def efgh_cube(q):\n    return q ** 3",
    "same_behavior": 1
  },
  {
    "function1": "def jklm_min(a, b):\n    return a if a < b else b",
    "function2": "def nopq_min(a, b):\n    return a if a > b else b",
    "same_behavior": 0
  },
  {
    "function1": "def rstu_sum_even(lst):\n    return sum(x for x in lst if x % 2 == 0)",
    "function2": "def vwxy_sum_even(numbers):\n    result = 0\n    for num in numbers:\n        if num % 2 == 0:\n            result += num\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def zzzz_alpha_count(s):\n    return sum(1 for ch in s if ch.isalpha())",
    "function2": "def yyyx_char_count(s):\n    return len(s)",
    "same_behavior": 0
  },
    {
    "function1": "def qwer1_consonants(s):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for ch in s:\n        if ch.isalpha() and ch not in vowels:\n            count += 1\n    return count",
    "function2": "def asdf1_consonants(s):\n    vowels = set('aeiouAEIOU')\n    return sum(1 for ch in s if ch.isalpha() and ch not in vowels)",
    "same_behavior": 1
  },
  {
    "function1": "def tyui_sum_cubes(nums):\n    total = 0\n    for n in nums:\n        total += n**3\n    return total",
    "function2": "def ghjk_sum_cubes(nums):\n    return sum(n**3 for n in nums)",
    "same_behavior": 1
  },
  {
    "function1": "def qwer2_is_palindrome(s):\n    import re\n    filtered = re.sub(r'[^A-Za-z0-9]', '', s).lower()\n    return filtered == filtered[::-1]",
    "function2": "def asdf2_is_palindrome(s):\n    filtered = ''.join(ch.lower() for ch in s if ch.isalnum())\n    rev = ''.join(reversed(filtered))\n    return filtered == rev",
    "same_behavior": 1
  },
  {
    "function1": "def zxcv1_intersect(list1, list2):\n    return [x for x in list1 if x in list2]",
    "function2": "def vbnm1_intersect(list1, list2):\n    return list(set(list1).intersection(set(list2)))",
    "same_behavior": 0
  },
  {
    "function1": "def poiu1_median(a, b, c):\n    return sorted([a, b, c])[1]",
    "function2": "def lkjh1_median(a, b, c):\n    if (a >= b and a <= c) or (a >= c and a <= b):\n        return a\n    elif (b >= a and b <= c) or (b >= c and b <= a):\n        return b\n    else:\n        return c",
    "same_behavior": 1
  },
  {
    "function1": "def mnbv1_isprime(n):\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True",
    "function2": "def vcxz1_isprime(n):\n    if n < 2:\n        return False\n    import math\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True",
    "same_behavior": 1
  },
  {
    "function1": "def qazx1_reverse_int(n):\n    sign = -1 if n < 0 else 1\n    s = str(abs(n))\n    return sign * int(s[::-1])",
    "function2": "def wsxc1_reverse_int(n):\n    sign = -1 if n < 0 else 1\n    n = abs(n)\n    rev = 0\n    while n:\n        rev = rev * 10 + n % 10\n        n //= 10\n    return sign * rev",
    "same_behavior": 1
  },
  {
    "function1": "def edcr1_triangular(n):\n    if n <= 0:\n        return 0\n    return n + edcr1_triangular(n-1)",
    "function2": "def rfvt1_triangular(n):\n    return n * (n + 1) // 2 if n > 0 else 0",
    "same_behavior": 1
  },
  {
    "function1": "def plkm1_second_smallest(lst):\n    uniq = sorted(set(lst))\n    return uniq[1] if len(uniq) >= 2 else None",
    "function2": "def okij1_second_smallest(lst):\n    first = second = float('inf')\n    for x in lst:\n        if x < first:\n            second = first\n            first = x\n        elif first < x < second:\n            second = x\n    return second if second != float('inf') else None",
    "same_behavior": 1
  },
  {
    "function1": "def nmlk1_distance(x1, y1, x2, y2):\n    from math import sqrt\n    return sqrt((x2 - x1)**2 + (y2 - y1)**2)",
    "function2": "def bvcx1_distance(x1, y1, x2, y2):\n    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5",
    "same_behavior": 1
  },
  {
    "function1": "def qaws1_diff(a, b):\n    return abs(a - b)",
    "function2": "def edcv1_diff(a, b):\n    return a - b",
    "same_behavior": 0
  },
  {
    "function1": "def rfgt1_concat(s1, s2):\n    return s1 + s2",
    "function2": "def tgbn1_concat(s1, s2):\n    return s1 + \" \" + s2",
    "same_behavior": 0
  },
  {
    "function1": "def yuio1_mult(a, b):\n    return a * b",
    "function2": "def iopm1_mult(a, b):\n    return a + b",
    "same_behavior": 0
  },
  {
    "function1": "def plko1_is_positive(n):\n    return n > 0",
    "function2": "def mikk1_is_positive(n):\n    return n >= 0",
    "same_behavior": 0
  },
  {
    "function1": "def nhbg1_starts_with_vowel(s):\n    return s[0].lower() in 'aeiou' if s else False",
    "function2": "def vfred1_ends_with_vowel(s):\n    return s[-1].lower() in 'aeiou' if s else False",
    "same_behavior": 0
  },
  {
    "function1": "def cdfv1_compound(P, r, n, t):\n    return P * (1 + r/n)**(n*t)",
    "function2": "def xswq1_simple(P, r, t):\n    return P * (1 + r*t)",
    "same_behavior": 0
  },
  {
    "function1": "def qazw1_is_empty(lst):\n    return len(lst) == 0",
    "function2": "def wsxe1_is_empty(lst):\n    return lst[0] is None if lst else True",
    "same_behavior": 0
  },
  {
    "function1": "def edcr2_reverse_tuple(tup):\n    return tuple(reversed(tup))",
    "function2": "def rfvt2_reverse_tuple(tup):\n    return list(tup)[::-1]",
    "same_behavior": 0
  },
  {
    "function1": "def tgby1_power(base, exp):\n    return base ** exp",
    "function2": "def ujni1_power(base, exp):\n    result = 1\n    for _ in range(exp - 1):\n        result *= base\n    return result",
    "same_behavior": 0
  },
  {
    "function1": "def wqer1_sort(lst):\n    return sorted(lst)",
    "function2": "def plmn1_sort(lst):\n    return sorted(lst, reverse=True)",
    "same_behavior": 0
  },
  {
    "function1": "def nuvx1_arithmetic(a, b):\n    return a + b",
    "function2": "def nuvx2_arithmetic(a, b):\n    return a - b",
    "same_behavior": 0
  },
  {
    "function1": "def opqr1_cube(n):\n    return n ** 3",
    "function2": "def opqr2_cube(n):\n    return n * n",
    "same_behavior": 0
  },
  {
    "function1": "def rstu1_len_and_upper(s):\n    return len(s) + len(s.upper())",
    "function2": "def rstu2_len_and_upper(s):\n    return len(s)",
    "same_behavior": 0
  },
  {
    "function1": "def vwxy1_sort_desc(lst):\n    return sorted(lst, reverse=True)",
    "function2": "def vwxy2_sort_desc(lst):\n    return sorted(lst)",
    "same_behavior": 0
  },
  {
    "function1": "def zabc1_power2(n):\n    return 2 ** n",
    "function2": "def zabc2_power2(n):\n    return n * 2",
    "same_behavior": 0
  },
  {
    "function1": "def defg1_list_product(lst):\n    product = 1\n    for x in lst:\n        product *= x\n    return product",
    "function2": "def defg2_list_product(lst):\n    return sum(lst)",
    "same_behavior": 0
  },
  {
    "function1": "def ghij1_extreme(lst):\n    return sorted(lst)[-1]",
    "function2": "def ghij2_extreme(lst):\n    return sorted(lst)[0]",
    "same_behavior": 0
  },
  {
    "function1": "def hijk1_filter_even(lst):\n    return [x for x in lst if x % 2 == 0]",
    "function2": "def hijk2_filter_even(lst):\n    return [x for x in lst if x % 2 != 0]",
    "same_behavior": 0
  },
  {
    "function1": "def ijkl1_reverse_str(s):\n    return s[::-1]",
    "function2": "def ijkl2_reverse_str(s):\n    return s",
    "same_behavior": 0
  },
  {
    "function1": "def jklm1_upper(s):\n    return s.upper()",
    "function2": "def jklm2_lower(s):\n    return s.lower()",
    "same_behavior": 0
  },
  {
    "function1": "def klmn1_even_count(lst):\n    return sum(1 for x in lst if x % 2 == 0)",
    "function2": "def klmn2_even_count(lst):\n    return sum(1 for x in lst if x % 2 != 0)",
    "same_behavior": 0
  },
  {
    "function1": "def lmno1_str_repeat(s, n):\n    return s * n",
    "function2": "def lmno2_str_repeat(s, n):\n    return \" \".join([s] * n)",
    "same_behavior": 0
  },
  {
    "function1": "def mnop1_modulo(a, b):\n    return a % b",
    "function2": "def mnop2_modulo(a, b):\n    return (a % b) + b",
    "same_behavior": 0
  },
  {
    "function1": "def nopq1_char_count(s):\n    return len(s)",
    "function2": "def nopq2_char_count(s):\n    return sum(1 for ch in s if ch.isalpha())",
    "same_behavior": 0
  },
  {
    "function1": "def opqr3_index_of_first(lst, target):\n    for i, x in enumerate(lst):\n        if x == target:\n            return i\n    return -1",
    "function2": "def opqr4_index_of_first(lst, target):\n    for i in range(len(lst)-1, -1, -1):\n        if lst[i] == target:\n            return i\n    return -1",
    "same_behavior": 0
  },
  {
    "function1": "def pqrs1_fahrenheit_to_celsius(f):\n    return (f - 32) * 5/9",
    "function2": "def pqrs2_fahrenheit_to_kelvin(f):\n    return (f - 32) * 5/9 + 273.15",
    "same_behavior": 0
  },
  {
    "function1": "def rstu3_factorial(n):\n    if n == 0:\n        return 1\n    return n * rstu3_factorial(n-1)",
    "function2": "def rstu4_fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
    "same_behavior": 0
  },
  {
    "function1": "def stuv4_even_index(lst):\n    return lst[::2]",
    "function2": "def stuv5_odd_index(lst):\n    return lst[1::2]",
    "same_behavior": 0
  },
  {
    "function1": "def tuvw1_append_exclamation(s):\n    return s + \"!\"",
    "function2": "def tuvw2_append_question(s):\n    return s + \"?\"",
    "same_behavior": 0
  },
  {
    "function1": "def uvwx4_even_numbers(n):\n    return list(range(0, n, 2))",
    "function2": "def uvwx5_even_numbers(n):\n    return [x for x in range(n) if x % 2 != 0]",
    "same_behavior": 0
  },
    {
    "function1": "def qzxy1_evensquare_sum(lst):\n    return sum(x*x for x in lst if x % 2 == 0)",
    "function2": "def qzxy2_evensquare_sum(lst):\n    total = 0\n    for x in lst:\n        if x % 2 == 0:\n            total += x*x\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def bzxc1_nonzero_product(lst):\n    prod = 1\n    for x in lst:\n        if x != 0:\n            prod *= x\n    return prod",
    "function2": "def bzxc2_nonzero_product(lst):\n    from functools import reduce\n    filtered = [x for x in lst if x != 0]\n    return reduce(lambda a, b: a*b, filtered, 1)",
    "same_behavior": 1
  },
  {
    "function1": "def xevy1_sub_count(s, sub):\n    return s.count(sub)",
    "function2": "def xevy2_sub_count(s, sub):\n    count = 0\n    index = 0\n    while True:\n        index = s.find(sub, index)\n        if index == -1:\n            break\n        count += 1\n        index += len(sub) if len(sub) > 0 else 1\n    return count",
    "same_behavior": 1
  },
  {
    "function1": "def cfqr1_is_perfect_square(n):\n    if n < 0:\n        return False\n    import math\n    root = math.isqrt(n)\n    return root * root == n",
    "function2": "def cfqr2_is_perfect_square(n):\n    if n < 0:\n        return False\n    root = int(n**0.5)\n    return root * root == n",
    "same_behavior": 1
  },
  {
    "function1": "def ytre1_cube_even_sum(lst):\n    return sum(x**3 for x in lst if x % 2 == 0)",
    "function2": "def ytre2_cube_even_sum(lst):\n    total = 0\n    for x in lst:\n        if x % 2 == 0:\n            total += x*x*x\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def wqer2_prod_digits(n):\n    prod = 1\n    for ch in str(abs(n)):\n        prod *= int(ch)\n    return prod",
    "function2": "def wqer3_prod_digits(n):\n    from functools import reduce\n    digits = [int(d) for d in str(abs(n))]\n    return reduce(lambda a, b: a*b, digits, 1)",
    "same_behavior": 1
  },
  {
    "function1": "def qwer3_longest_word(lst):\n    return max(lst, key=len) if lst else ''",
    "function2": "def qwer4_longest_word(lst):\n    longest = ''\n    for word in lst:\n        if len(word) > len(longest):\n            longest = word\n    return longest",
    "same_behavior": 1
  },
  {
    "function1": "def asdf3_flat_keys(d):\n    keys = []\n    for k, v in d.items():\n        keys.append(k)\n        if isinstance(v, dict):\n            keys.extend(asdf3_flat_keys(v))\n    return keys",
    "function2": "def asdf4_flat_keys(d):\n    result = []\n    for key in d:\n        result.append(key)\n        if isinstance(d[key], dict):\n            result += asdf4_flat_keys(d[key])\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def zyxw1_gcd_three(a, b, c):\n    import math\n    return math.gcd(math.gcd(a, b), c)",
    "function2": "def zyxw2_gcd_three(a, b, c):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    return gcd(gcd(a, b), c)",
    "same_behavior": 1
  },
  {
    "function1": "def poiu1_sort_by_tuple_sum(lst):\n    return sorted(lst, key=lambda t: sum(t))",
    "function2": "def poiu2_sort_by_tuple_sum(lst):\n    lst_copy = lst[:]\n    lst_copy.sort(key=lambda t: sum(t))\n    return lst_copy",
    "same_behavior": 1
  },
  {
    "function1": "def klop1_list_to_csv(lst):\n    return ','.join(str(x) for x in lst)",
    "function2": "def klop2_list_to_csv(lst):\n    result = ''\n    for i, x in enumerate(lst):\n        result += str(x)\n        if i < len(lst)-1:\n            result += ','\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def mnbv2_harmonic_sum(n):\n    return sum(1.0/i for i in range(1, n+1))",
    "function2": "def mnbv3_harmonic_sum(n):\n    total = 0.0\n    for i in range(1, n+1):\n        total += 1.0/i\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def poiu3_index_max(lst):\n    return lst.index(max(lst)) if lst else -1",
    "function2": "def poiu4_index_max(lst):\n    if not lst:\n        return -1\n    max_index = 0\n    for i in range(1, len(lst)):\n        if lst[i] > lst[max_index]:\n            max_index = i\n    return max_index",
    "same_behavior": 1
  },
  {
    "function1": "def asdf5_rotate_list(lst, k):\n    k = k % len(lst) if lst else 0\n    return lst[k:] + lst[:k]",
    "function2": "def asdf6_rotate_list(lst, k):\n    from collections import deque\n    dq = deque(lst)\n    dq.rotate(-k)\n    return list(dq)",
    "same_behavior": 1
  },
  {
    "function1": "def zxcv2_unique_order(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
    "function2": "def zxcv3_unique_order(lst):\n    return list(dict.fromkeys(lst))",
    "same_behavior": 1
  },
  {
    "function1": "def qzxy1_evensquare_sum(lst):\n    return sum(x*x for x in lst if x % 2 == 0)",
    "function2": "def qzxy2_evensquare_sum(lst):\n    total = 0\n    for x in lst:\n        if x % 2 == 0:\n            total += x*x\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def bzxc1_nonzero_product(lst):\n    prod = 1\n    for x in lst:\n        if x != 0:\n            prod *= x\n    return prod",
    "function2": "def bzxc2_nonzero_product(lst):\n    from functools import reduce\n    filtered = [x for x in lst if x != 0]\n    return reduce(lambda a, b: a*b, filtered, 1)",
    "same_behavior": 1
  },
  {
    "function1": "def xevy1_sub_count(s, sub):\n    return s.count(sub)",
    "function2": "def xevy2_sub_count(s, sub):\n    count = 0\n    index = 0\n    while True:\n        index = s.find(sub, index)\n        if index == -1:\n            break\n        count += 1\n        index += len(sub) if len(sub) > 0 else 1\n    return count",
    "same_behavior": 1
  },
  {
    "function1": "def cfqr1_is_perfect_square(n):\n    if n < 0:\n        return False\n    import math\n    root = math.isqrt(n)\n    return root * root == n",
    "function2": "def cfqr2_is_perfect_square(n):\n    if n < 0:\n        return False\n    root = int(n**0.5)\n    return root * root == n",
    "same_behavior": 1
  },
  {
    "function1": "def ytre1_cube_even_sum(lst):\n    return sum(x**3 for x in lst if x % 2 == 0)",
    "function2": "def ytre2_cube_even_sum(lst):\n    total = 0\n    for x in lst:\n        if x % 2 == 0:\n            total += x*x*x\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def wqer2_prod_digits(n):\n    prod = 1\n    for ch in str(abs(n)):\n        prod *= int(ch)\n    return prod",
    "function2": "def wqer3_prod_digits(n):\n    from functools import reduce\n    digits = [int(d) for d in str(abs(n))]\n    return reduce(lambda a, b: a*b, digits, 1)",
    "same_behavior": 1
  },
  {
    "function1": "def qwer3_longest_word(lst):\n    return max(lst, key=len) if lst else ''",
    "function2": "def qwer4_longest_word(lst):\n    longest = ''\n    for word in lst:\n        if len(word) > len(longest):\n            longest = word\n    return longest",
    "same_behavior": 1
  },
  {
    "function1": "def asdf3_flat_keys(d):\n    keys = []\n    for k, v in d.items():\n        keys.append(k)\n        if isinstance(v, dict):\n            keys.extend(asdf3_flat_keys(v))\n    return keys",
    "function2": "def asdf4_flat_keys(d):\n    result = []\n    for key in d:\n        result.append(key)\n        if isinstance(d[key], dict):\n            result += asdf4_flat_keys(d[key])\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def zyxw1_gcd_three(a, b, c):\n    import math\n    return math.gcd(math.gcd(a, b), c)",
    "function2": "def zyxw2_gcd_three(a, b, c):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    return gcd(gcd(a, b), c)",
    "same_behavior": 1
  },
  {
    "function1": "def poiu1_sort_by_tuple_sum(lst):\n    return sorted(lst, key=lambda t: sum(t))",
    "function2": "def poiu2_sort_by_tuple_sum(lst):\n    lst_copy = lst[:]\n    lst_copy.sort(key=lambda t: sum(t))\n    return lst_copy",
    "same_behavior": 1
  },
  {
    "function1": "def klop1_list_to_csv(lst):\n    return ','.join(str(x) for x in lst)",
    "function2": "def klop2_list_to_csv(lst):\n    result = ''\n    for i, x in enumerate(lst):\n        result += str(x)\n        if i < len(lst)-1:\n            result += ','\n    return result",
    "same_behavior": 1
  },
  {
    "function1": "def mnbv2_harmonic_sum(n):\n    return sum(1.0/i for i in range(1, n+1))",
    "function2": "def mnbv3_harmonic_sum(n):\n    total = 0.0\n    for i in range(1, n+1):\n        total += 1.0/i\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def poiu3_index_max(lst):\n    return lst.index(max(lst)) if lst else -1",
    "function2": "def poiu4_index_max(lst):\n    if not lst:\n        return -1\n    max_index = 0\n    for i in range(1, len(lst)):\n        if lst[i] > lst[max_index]:\n            max_index = i\n    return max_index",
    "same_behavior": 1
  },
  {
    "function1": "def asdf5_rotate_list(lst, k):\n    k = k % len(lst) if lst else 0\n    return lst[k:] + lst[:k]",
    "function2": "def asdf6_rotate_list(lst, k):\n    from collections import deque\n    dq = deque(lst)\n    dq.rotate(-k)\n    return list(dq)",
    "same_behavior": 1
  },
  {
    "function1": "def qwer5_mad(lst):\n    if not lst:\n        return 0\n    sorted_lst = sorted(lst)\n    n = len(sorted_lst)\n    median = sorted_lst[n//2] if n % 2 == 1 else (sorted_lst[n//2 - 1] + sorted_lst[n//2]) / 2\n    deviations = [abs(x - median) for x in lst]\n    deviations.sort()\n    m = len(deviations)\n    return deviations[m//2] if m % 2 == 1 else (deviations[m//2 - 1] + deviations[m//2]) / 2",
    "function2": "def qwer6_mad(lst):\n    if not lst:\n        return 0\n    m = len(lst)\n    sorted_lst = sorted(lst)\n    if m % 2 == 1:\n        med = sorted_lst[m//2]\n    else:\n        med = (sorted_lst[m//2 - 1] + sorted_lst[m//2]) / 2\n    dev = sorted([abs(x - med) for x in lst])\n    m_dev = len(dev)\n    return dev[m_dev//2] if m_dev % 2 == 1 else (dev[m_dev//2 - 1] + dev[m_dev//2]) / 2",
    "same_behavior": 1
  },
  {
    "function1": "def zxcv2_unique_order(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
    "function2": "def zxcv3_unique_order(lst):\n    return list(dict.fromkeys(lst))",
    "same_behavior": 1
  },
  {
    "function1": "def asdf7_is_isogram(s):\n    s = s.lower()\n    return len(set(s)) == len(s)",
    "function2": "def asdf8_is_isogram(s):\n    seen = []\n    for ch in s.lower():\n        if ch in seen:\n            return False\n        seen.append(ch)\n    return True",
    "same_behavior": 1
  },
  {
    "function1": "def poiu5_power_sum(lst, exp):\n    return sum(x**exp for x in lst)",
    "function2": "def poiu6_power_sum(lst, exp):\n    total = 0\n    for x in lst:\n        total += x**exp\n    return total",
    "same_behavior": 1
  },
  {
    "function1": "def zxcv4_alternate_case(s):\n    result = ''\n    for i, ch in enumerate(s):\n        result += ch.upper() if i % 2 == 0 else ch.lower()\n    return result",
    "function2": "def zxcv5_alternate_case(s):\n    return ''.join(ch.upper() if i % 2 == 0 else ch.lower() for i, ch in enumerate(s))",
    "same_behavior": 1
  },
    {
    "function1": "def rtyu1_sum_even(lst):\n    return sum(x for x in lst if x % 2 == 0)",
    "function2": "def rtyu2_sum_odd(lst):\n    return sum(x for x in lst if x % 2 != 0)",
    "same_behavior": 0
  },
  {
    "function1": "def cvbn1_average(lst):\n    return sum(lst)/len(lst) if lst else 0",
    "function2": "def cvbn2_median(lst):\n    if not lst:\n        return 0\n    sorted_lst = sorted(lst)\n    n = len(sorted_lst)\n    if n % 2 == 1:\n        return sorted_lst[n//2]\n    else:\n        return (sorted_lst[n//2 - 1] + sorted_lst[n//2]) / 2",
    "same_behavior": 0
  },
  {
    "function1": "def bnmk1_reverse_string(s):\n    return s[::-1]",
    "function2": "def bnmk2_identity_string(s):\n    return s",
    "same_behavior": 0
  },
  {
    "function1": "def qwer7_multiply_list(lst):\n    prod = 1\n    for x in lst:\n        prod *= x\n    return prod",
    "function2": "def qwer8_sum_list(lst):\n    return sum(lst)",
    "same_behavior": 0
  },
  {
    "function1": "def qwer9_concat_space(s1, s2):\n    return s1 + ' ' + s2",
    "function2": "def qwer10_concat_no_space(s1, s2):\n    return s1 + s2",
    "same_behavior": 0
  },
  {
    "function1": "def zxcv8_sort_asc(lst):\n    return sorted(lst)",
    "function2": "def zxcv9_sort_desc(lst):\n    return sorted(lst, reverse=True)",
    "same_behavior": 0
  },
  {
    "function1": "def asdf11_first_n(s, n):\n    return s[:n]",
    "function2": "def asdf12_last_n(s, n):\n    return s[-n:] if n <= len(s) else s",
    "same_behavior": 0
  },
  {
    "function1": "def poiu9_geometric_mean(lst):\n    import math\n    if not lst or any(x <= 0 for x in lst):\n        return 0\n    prod = 1\n    for x in lst:\n        prod *= x\n    return prod ** (1/len(lst))",
    "function2": "def poiu10_arithmetic_mean(lst):\n    return sum(lst)/len(lst) if lst else 0",
    "same_behavior": 0
  },
  {
    "function1": "def asdf13_reverse_list(lst):\n    return lst[::-1]",
    "function2": "def asdf14_sorted_list(lst):\n    return sorted(lst)",
    "same_behavior": 0
  },
  {
    "function1": "def qwert5_even_numbers(lst):\n    return [x for x in lst if x % 2 == 0]",
    "function2": "def qwert6_gt_ten(lst):\n    return [x for x in lst if x > 10]",
    "same_behavior": 0
  },
  {
    "function1": "def zxcv12_vowel_count(s):\n    vowels = 'aeiouAEIOU'\n    return sum(1 for ch in s if ch in vowels)",
    "function2": "def zxcv13_consonant_count(s):\n    vowels = 'aeiouAEIOU'\n    return sum(1 for ch in s if ch.isalpha() and ch not in vowels)",
    "same_behavior": 0
  },
  {
    "function1": "def poiu11_square_value(n):\n    return n**2",
    "function2": "def poiu12_absolute_value(n):\n    return abs(n)",
    "same_behavior": 0
  },
  {
    "function1": "def asdf15_list_intersection(lst1, lst2):\n    return [x for x in lst1 if x in lst2]",
    "function2": "def asdf16_list_union(lst1, lst2):\n    return list(set(lst1) | set(lst2))",
    "same_behavior": 0
  },
  {
    "function1": "def qwert7_sum_elements(lst):\n    return sum(lst)",
    "function2": "def qwert8_product_elements(lst):\n    prod = 1\n    for x in lst:\n        prod *= x\n    return prod",
    "same_behavior": 0
  },
  {
    "function1": "def poiu13_round_number(x):\n    return round(x, 2)",
    "function2": "def poiu14_floor_number(x):\n    import math\n    return math.floor(x)",
    "same_behavior": 0
  },
  {
    "function1": "def asdf17_increment_all(lst):\n    return [x+1 for x in lst]",
    "function2": "def asdf18_decrement_all(lst):\n    return [x-1 for x in lst]",
    "same_behavior": 0
  }
]
